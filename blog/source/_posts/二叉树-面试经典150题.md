---
title: 二叉树 --面试经典150题
date: 2024-12-25 10:45:30
tags:
    - 二叉树
    - 面试经典150题
    - leetcode
---

## 相同的树(easy)
### 做题过程
不太记得了，反正就是选一个遍历方式一个一个比对，DFS或者BFS。

### 算法概述
[原题](https://leetcode.cn/problems/same-tree/description/?envType=study-plan-v2&envId=top-interview-150)

本题要求为比较两个树是否相同。
- 时间复杂度为O(min(n,m))：不一样就是比完一棵较小的树就行
- 空间复杂度为O(min(n,m))：递归

### JAVA
```java
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null && q == null) {
            return true;
        } else if (p == null || q == null) {
            return false;
        } else if (p.val != q.val) {
            return false;
        } else {
            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
        }
    }
}
```

### 总结
先左再右或者先右再左都一样。要注意一开始要考虑递归到最底层（自底向上）的情况，然后才是`false`的情况。


## 从中序与后序遍历序列构造二叉树(medium)
### 做题过程
感觉和前序中序的那道题的思路还是差别蛮大的，还是不太会。

### 算法概述
[原题](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/?envType=study-plan-v2&envId=top-interview-150)

本题要求为如题所示。采用 ***递归*** （迭代同理）。
- 时间复杂度为O(n)
- 空间复杂度为O(n)

### JAVA
```java
class Solution {
    // 全局变量用不用其实没关系，但是用了确实好一些
    int post_idx;
    int[] postorder;
    int[] inorder;

    // 中序遍历的映射关系
    Map<Integer, Integer> idx_map = new HashMap<Integer, Integer>();

    // 递归
    public TreeNode helper(int in_left, int in_right) {
        // 双指针相遇，结束
        if (in_left > in_right) {
            return null;
        }

        // 选择 post_idx 位置的元素作为当前子树根节点（后序遍历得到根节点位置）
        int root_val = postorder[post_idx];
        TreeNode root = new TreeNode(root_val);

        // 找到根节点在中序遍历中的位置
        int index = idx_map.get(root_val);

        // 下标减一，更新根节点（按照后序遍历顺序，进入右子树）
        post_idx--;
        // 先构造右子树
        root.right = helper(index + 1, in_right);
        // 再构造左子树
        root.left = helper(in_left, index - 1);
        return root;
    }

    public TreeNode buildTree(int[] inorder, int[] postorder) {
        this.postorder = postorder;
        this.inorder = inorder;
        // 从后序遍历的最后一个元素开始（整棵树的根节点）
        post_idx = postorder.length - 1;

        // 建立（元素，下标）键值对的哈希表
        int idx = 0;
        for (Integer val : inorder) {
            idx_map.put(val, idx++);
        }
        
        // 双指针初始指向中序遍历左右边界
        return helper(0, inorder.length - 1);
    }
}
```
 
### 总结
和前序遍历一样，后序遍历的意义主要在于 **找到根节点** ，而中序遍历可以在定位根节点之后 **快速找到左孩子和右孩子** ，重要的是当孩子不存在时，可以直接 **通过缩小左右指针** ，判断出来这种情况，这是因为搭建过程是 **自顶向下** 的。


## 填充每个节点的下一个右侧节点指针 II(medium)
### 做题过程
我想的还是要用BFS，但是怎么组织代码结构来实现，还是没想出来。

### 算法概述
[原题](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/description/?envType=study-plan-v2&envId=top-interview-150)

本题要求为将每个节点的next指针指向它们同一层的右侧节点。模拟解决，但是算法可以更加巧妙。
- 时间复杂度为O(n)
- 空间复杂度为O(n)：可以通过技巧优化至O(1)

### JAVA
```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}
    
    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};
*/

class Solution {
    public Node connect(Node root) {
        // 标准BFS
        if(root==null) return root;
        Queue<Node> queue=new LinkedList<>();
        queue.offer(root);
        
        // 标准终止条件 
        while(!queue.isEmpty()){
             int size=queue.size();
            Node last=null;
            // 一直到队列为空，不用while是因为要处理root的情况
            for(int i=0;i!=size;++i){
                // 标准BFS
                Node n=queue.poll();
                if(n.left!=null) queue.offer(n.left);
                if(n.right!=null) queue.offer(n.right);
                // 按照队列内部顺序连接
                if(i!=0) last.next=n;
                // 用一个中间变量改变当前目标节点
                last=n;
            }
        }
        return root;
    }
}
```

### 总结
这道题主要考察的还是对迭代的理解，这里用到的是标准BFS的两个（可更改的）迭代特性：
- 从左到右新增节点
- 连接操作的次数正好跟迭代次数相同

还有一种降低空间复杂度的方法也是直接模拟，从上一层对下一层的next进行操作，这是额外将每层最右侧节点和下一层最左侧节点连接实现的，也就是一个变量指向即将连接的节点，另外一个节点指向，即将被连接节点的根节点。很巧妙。

