---
title: 图论 --面试经典150题
date: 2024-12-30 14:48:59
tags:
    - 图论
    - 面试经典150题
    - leetcode
---

## 被围绕的区域(medium)
### 做题过程
大概清楚肯定还是DFS和BFS都可以，但问题是该怎么组织代码结构，完全没有思路。而且抄都能抄错好几次。

### 算法概述
[原题](https://leetcode.cn/problems/surrounded-regions/description/?envType=study-plan-v2&envId=top-interview-150)

本题要求为给出二维矩阵，需要通过原地操作将其中被'X'完全包围的'O'转换为'X'（在边界不算）。DFS看上去好写一些。
- 时间复杂度为O(n*m)
- 空间复杂度为O(n*m)

### JAVA
```java
class Solution {
    int n, m;

    public void solve(char[][] board) {
        n = board.length;
        m = board[0].length;
        // 再加一个m的检查就会编程2ms了，非常神奇，不过也确实不用检查m
        if (n == 0)
            return;
        
        for (int i = 0; i < n; i++) {
            // 竖着的两个边界 
            dfs(board, i, 0);
            dfs(board, i, m - 1);
        }

        for (int i = 1; i < m - 1; ++i) {
            // 横着的两个边界
            dfs(board, 0, i);
            dfs(board, n - 1, i);
        }

        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                // A代表和边界的O连着
                if (board[i][j] == 'A') {
                    board[i][j] = 'O';
                    // 原本的O代表和边界的O是隔绝（即被X所包围）
                } else if (board[i][j] == 'O') {
                    board[i][j] = 'X';
                }
            }
        }
    }

    // 找和边界上的O连着的其他O
    public void dfs(char[][] board, int x, int y) {
        // 是X或者是A或者越界就停止了
        if (x < 0 || x >= n || y < 0 || y >= m || board[x][y] != 'O')
            return;
        // 是O就先设置为A
        board[x][y] = 'A';
        // 上下左右
        dfs(board, x + 1, y);
        dfs(board, x - 1, y);
        dfs(board, x, y + 1);
        dfs(board, x, y - 1);
    }
}
```

### 总结
总而言之，思路如下：
1. 检查四个边界的O
2. 对边界上的O进行上下左右的移动递归，碰到标记过的或者X即停止（也就是没有连接的O了）
3. 再次遍历整个矩阵，将标记转化回O，非标记O转化为X（捕获）

比较妙的地方是高效完成了边界连通O的筛选工作，通过 **递归** 和 **记录标记** ，但这里并没有用标记数组，而是 **直接原地标记** 。

 
