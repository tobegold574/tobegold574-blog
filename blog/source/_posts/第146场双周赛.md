---
title: 第146场双周赛
date: 2024-12-23 14:26:45
tags:
    - 周赛
    - leetcode
---
[🚀竞赛](https://leetcode.cn/contest/biweekly-contest-146/)


## 统计符合条件长度为3的子数组数目
### 做题过程
滑动窗口即可。

### 算法概述
本题要求为求多少个子数组中第一个和第三个数之和为第二个数的一半。 ***滑动窗口*** 秒了。
- 时间复杂度为O(n)
- 空间复杂度为O(1)

### JAVA
```java
class Solution {
    public int countSubarrays(int[] nums) {
        int l=0,r=2;
        int ans=0;
        while(r<nums.length){
            // 要转换成浮点数，不然判断奇数或者0、1会有问题
            if((float)nums[l]+nums[r]==(float)nums[(l+r)/2]/2) ans++;
            l++;
            r++;
        }
        return ans;
    }
}
```

### 总结
要转换为浮点数避免奇数除法只取整的问题。


## 统计异或值为给定值的路径数目
### 做题过程
使用了深度优先搜索遍历所有路径，使用了哈希表进行记忆化搜索剪枝优化，但是时间还是超了。因为哈希集合的查找开销还是高，即使是常数（毕竟是hash🥔）。
### 算法概述
本题要求位路径上所有值的异或值必须为给定值，统计符合要求的路径数。采用灵神的解法，用 ***动态规划*** 替代散列集。
- 时间复杂度为O(m\*n\*u)：u是最大的异或值范围，最坏情况下范围内每个异或值都可能出现
- 空间复杂度为O(m\*n\*u)：dp数组

### JAVA
```java
class Solution {
    private static final int MOD = 1_000_000_007;

    public int countPathsWithXorValue(int[][] grid, int k) {
        int mx = 0;
        for (int[] row : grid) {
            for (int val : row) {
                mx = Math.max(mx, val);
            }
        }
        // 计算异或值范围
        int u = 1 << (32 - Integer.numberOfLeadingZeros(mx));
        // 如果K比最大的异或值还要大，那就没有路径
        if (k >= u) {
            return 0;
        }
    
        int m = grid.length;
        int n = grid[0].length;
        // 记忆化搜索(dp数组)
        int[][][] memo = new int[m][n][u];
        for (int[][] mat : memo) {
            for (int[] row : mat) {
                Arrays.fill(row, -1);
            }
        }
        // 逆向搜索
        return dfs(grid, m - 1, n - 1, k, memo);
    }

    private int dfs(int[][] grid, int i, int j, int x, int[][][] memo) {
        // 越没越界
        if (i < 0 || j < 0) {
            return 0;
        }
        int val = grid[i][j];
        // 回到起点了
        if (i == 0 && j == 0) {
            return x == val ? 1 : 0;
        }
        // 我原来用的是哈希集合
        if (memo[i][j][x] != -1) {
            return memo[i][j][x];
        }
        // 移动
        int left = dfs(grid, i, j - 1, x ^ val, memo);
        int up = dfs(grid, i - 1, j, x ^ val, memo);
        // 计算异或值（逆序需要这样放）
        return memo[i][j][x] = (left + up) % MOD;
    }
}
```

#### 重要实例方法及属性(JAVA)
- `Integer.numberOfLeadingZeros(mx)`：计算前导0的数量
- `<<1`：生成一个2的幂次方的数字
- `int u = 1 << (32 - Integer.numberOfLeadingZeros(mx));`：计算异或值的最大范围

### 总结
**重要😠** ：
- 哈希集合的常数时间 **不如** 记忆化搜索！
- 逆序搜索更易于处理边界，在其他类型的题目中(e.g., 符合条件的路径)还能剪枝
- 用 **要求条件的最大值** 作为多维动态规划的 **第三维** ！