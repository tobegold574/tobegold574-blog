---
title: 链表 --面试经典150题
date: 2024-12-23 11:03:14
tags:
    - 链表
    - 面试经典150题
    - leetcode
---

## 反转链表 II
### 做题过程
比反转链表I多了要处理环的问题，但是其实也不需要显式处理，可以用好的代码代替显式处理，这个地方弄得焦头烂额也没弄对。

### 算法概述
[原题](https://leetcode.cn/problems/reverse-linked-list-ii/description/?envType=study-plan-v2&envId=top-interview-150)

本题要求为反转给出范围内的链表。
- 时间复杂度为O(n)
- 空间复杂度为O(1)

### JAVA
```java
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        // 空链表和空区间检查
        if (head == null || left == right) {
            return head;  
        }

        // 创建一个哑节点，简化边界操作
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode prev = dummy;

        // 定位到 left - 1 位置（即反转区间左侧外部第一个节点）
        for (int i = 0; i < left - 1; i++) {
            prev = prev.next;
        }

        ListNode curr = prev.next;
        ListNode next = curr.next;

        // 开始反转过程（不断将后面的节点，即next，插入到前面）
        for (int i = 0; i < right - left; i++) {
            // 把curr和next的后一个节点连接
            curr.next = next.next;  
            // 把next与prev的后一个节点连接（插入）
            next.next = prev.next;  
            // 把prev与next连接（插入）
            prev.next = next;
            // 只需要更新next       
            next = curr.next;       
        }

        return dummy.next;  // 返回新的链表头
    }
}
```

### 总结
与 **迭代** 不同，上述解法可以 **保留前驱** ，并且`curr`是 **自动移动** 的，只需更新`next`即可，因为在插入的过程中，区间是固定的，所以前驱是固定的，并且每次操作的对象都是`curr`之后的节点（往前插入），而`curr`会逐渐从区间内第一个节点变成最后一个节点。



 
